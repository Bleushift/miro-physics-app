<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PP Protractor</title>
<script src="https://miro.com/app/static/sdk/v2/miro.js"></script>
<style>
  :root {
    --bg: #f5f5fa;
    --surface: #ffffff;
    --border: #d4d4e0;
    --text: #1e1e2e;
    --muted: #64748b;
    --purple: #7C3AED;
  }

  [data-theme="dark"] {
    --bg: #1e1e2e;
    --surface: #26263a;
    --border: #38385a;
    --text: #e2e2f0;
    --muted: #888aaa;
    --purple: #a78bfa;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    font-size: 13px;
    background: var(--bg);
    color: var(--text);
    width: 280px;
    min-height: 420px;
    overflow-x: hidden;
  }

  .header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 14px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
  }

  .header-left {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .header-left svg { flex-shrink: 0; }

  .header-title {
    font-size: 13px;
    font-weight: 600;
    color: var(--text);
    letter-spacing: -0.01em;
  }

  .theme-toggle {
    background: none;
    border: 1px solid var(--border);
    border-radius: 6px;
    width: 28px;
    height: 28px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    line-height: 1;
    transition: background 0.15s, border-color 0.15s;
  }

  .theme-toggle:hover {
    background: var(--surface);
    border-color: var(--purple);
  }

  .content {
    padding: 16px 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
  }

  .canvas-wrap {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  #protoCanvas {
    display: block;
    max-width: 100%;
    height: auto;
  }

  .label {
    font-size: 11px;
    font-weight: 500;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.04em;
    align-self: flex-start;
    margin-left: 4px;
  }

  .place-btn {
    width: 100%;
    padding: 10px 0;
    background: var(--purple);
    color: #ffffff;
    border: none;
    border-radius: 8px;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: opacity 0.15s, transform 0.1s;
    letter-spacing: -0.01em;
  }

  .place-btn:hover { opacity: 0.92; }
  .place-btn:active { transform: scale(0.98); }
  .place-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

  .footer-note {
    font-size: 11px;
    color: var(--muted);
    text-align: center;
    line-height: 1.4;
  }

  /* ── Selected item controls ── */
  .selected-section {
    display: none;
    width: 100%;
    border-top: 1px solid var(--border);
    padding-top: 14px;
  }

  .selected-section.visible {
    display: block;
  }

  .angle-display {
    text-align: center;
    font-size: 32px;
    font-weight: 700;
    color: var(--purple);
    margin: 8px 0 12px;
    font-variant-numeric: tabular-nums;
  }

  .angle-row {
    display: flex;
    gap: 6px;
    align-items: center;
  }

  .angle-input {
    flex: 1;
    padding: 8px 10px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--surface);
    color: var(--text);
    font-size: 13px;
    font-family: inherit;
    text-align: center;
  }

  .angle-input:focus {
    outline: none;
    border-color: var(--purple);
  }

  .angle-btn {
    padding: 8px 12px;
    border: 1px solid var(--purple);
    border-radius: 6px;
    background: var(--purple);
    color: #fff;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    font-family: inherit;
    white-space: nowrap;
  }

  .angle-btn:hover { opacity: 0.9; }

  .angle-btn.secondary {
    background: var(--surface);
    color: var(--purple);
  }

  .angle-btn.secondary:hover {
    background: var(--purple);
    color: #fff;
  }

  .angle-presets {
    display: flex;
    gap: 4px;
    margin-top: 8px;
  }

  .preset-btn {
    flex: 1;
    padding: 6px 0;
    border: 1px solid var(--border);
    border-radius: 5px;
    background: var(--surface);
    color: var(--muted);
    font-size: 11px;
    cursor: pointer;
    font-family: inherit;
  }

  .preset-btn:hover {
    border-color: var(--purple);
    color: var(--purple);
  }
</style>
</head>
<body>

<div class="header">
  <div class="header-left">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="20" height="20">
      <rect width="64" height="64" rx="12" fill="#1a1a2e"/>
      <text x="32" y="44" text-anchor="middle" font-family="Georgia, serif" font-size="36" fill="#a78bfa">&#x1D453;</text>
    </svg>
    <span class="header-title">Physics Pathway</span>
  </div>
  <button class="theme-toggle" id="themeBtn" title="Toggle theme">&#x2600;&#xFE0F;</button>
</div>

<div class="content">
  <span class="label">Preview</span>
  <div class="canvas-wrap">
    <canvas id="protoCanvas"></canvas>
  </div>
  <button class="place-btn" id="placeBtn">Place on Board</button>
  <p class="footer-note">Drops a high-res protractor image<br>at the centre of your viewport.</p>

  <!-- Selected protractor controls -->
  <div class="selected-section" id="selectedSection">
    <span class="label">Protractor Selected</span>
    <div class="angle-display" id="angleDisplay">0.0&deg;</div>
    <div class="angle-row">
      <input type="number" class="angle-input" id="angleInput" placeholder="0" min="-360" max="360" step="0.1" />
      <button class="angle-btn" id="setAngleBtn">Set</button>
      <button class="angle-btn secondary" id="readAngleBtn" title="Read current angle from board">&#x21BB;</button>
    </div>
    <div class="angle-presets">
      <button class="preset-btn" data-angle="0">0&deg;</button>
      <button class="preset-btn" data-angle="30">30&deg;</button>
      <button class="preset-btn" data-angle="45">45&deg;</button>
      <button class="preset-btn" data-angle="90">90&deg;</button>
      <button class="preset-btn" data-angle="180">180&deg;</button>
    </div>
  </div>
</div>

<script>
/* ── Theme ─────────────────────────────────────────── */
const themeBtn = document.getElementById('themeBtn');
const STORAGE_KEY = 'pp-protractor-theme';

function applyTheme(theme) {
  document.documentElement.setAttribute('data-theme', theme);
  themeBtn.textContent = theme === 'dark' ? '\u{1F319}' : '\u{2600}\u{FE0F}';
  localStorage.setItem(STORAGE_KEY, theme);
}

(function initTheme() {
  const saved = localStorage.getItem(STORAGE_KEY) || 'light';
  applyTheme(saved);
})();

themeBtn.addEventListener('click', () => {
  const current = document.documentElement.getAttribute('data-theme') || 'light';
  applyTheme(current === 'dark' ? 'light' : 'dark');
});

/* ── Protractor Drawing ────────────────────────────── */
const PREVIEW_R = 120;
let selectedItem = null;

function drawProtractorOnCtx(ctx, R, pad, scale, angleText) {
  const fullW = (R + pad) * 2;
  const fullH = R + pad + (R <= 120 ? 28 : 36);
  const cx = fullW / 2;
  const cy = R + pad;

  ctx.clearRect(0, 0, fullW * scale, fullH * scale);
  ctx.save();
  ctx.scale(scale, scale);

  // Dark glass body
  ctx.beginPath();
  ctx.arc(cx, cy, R, Math.PI, 0);
  ctx.lineTo(cx + R, cy + 24);
  ctx.lineTo(cx - R, cy + 24);
  ctx.closePath();
  ctx.fillStyle = 'rgba(20, 20, 20, 0.6)';
  ctx.fill();

  // Purple highlight
  ctx.beginPath();
  ctx.arc(cx, cy, R, Math.PI, 0);
  ctx.arc(cx, cy, R - 10, 0, Math.PI, true);
  ctx.closePath();
  var hlGrd = ctx.createLinearGradient(cx, cy - R, cx, cy - R + 16);
  hlGrd.addColorStop(0, 'rgba(168, 85, 247, 0.15)');
  hlGrd.addColorStop(1, 'rgba(168, 85, 247, 0)');
  ctx.fillStyle = hlGrd;
  ctx.fill();

  // Inner guide arc
  ctx.beginPath();
  ctx.arc(cx, cy, R - 35, Math.PI, 0);
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Border
  ctx.beginPath();
  ctx.arc(cx, cy, R, Math.PI, 0);
  ctx.lineTo(cx + R, cy + 24);
  ctx.lineTo(cx - R, cy + 24);
  ctx.closePath();
  ctx.strokeStyle = 'rgba(168, 85, 247, 0.4)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Tick marks and labels
  for (var deg = 0; deg <= 180; deg++) {
    var rad = (180 - deg) * Math.PI / 180;
    var isTen = deg % 10 === 0;
    var isFive = deg % 5 === 0;
    var tickLen = isTen ? 14 : isFive ? 9 : 5;
    var ox = cx + R * Math.cos(rad);
    var oy = cy - R * Math.sin(rad);
    var ix = cx + (R - tickLen) * Math.cos(rad);
    var iy = cy - (R - tickLen) * Math.sin(rad);
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(ix, iy);
    ctx.strokeStyle = isTen ? 'rgba(255,255,255,0.9)' : isFive ? 'rgba(255,255,255,0.5)' : 'rgba(255,255,255,0.2)';
    ctx.lineWidth = isTen ? 1.5 : 0.8;
    ctx.stroke();
    if (isTen) {
      var lr = R - 24;
      var lx = cx + lr * Math.cos(rad);
      var ly = cy - lr * Math.sin(rad);
      ctx.save();
      ctx.translate(lx, ly);
      ctx.rotate(-rad + Math.PI / 2);
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.font = (deg % 30 === 0 ? '600' : '400') + ' 9px -apple-system, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(deg), 0, 0);
      ctx.restore();
    }
  }

  // Base line
  ctx.beginPath();
  ctx.moveTo(cx - R, cy);
  ctx.lineTo(cx + R, cy);
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // 90 degree dashed line
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx, cy - R);
  ctx.strokeStyle = 'rgba(168, 85, 247, 0.4)';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 4]);
  ctx.stroke();
  ctx.setLineDash([]);

  // Center point
  ctx.beginPath();
  ctx.arc(cx, cy, 4, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(20,20,20,1)';
  ctx.fill();
  ctx.beginPath();
  ctx.arc(cx, cy, 2, 0, Math.PI * 2);
  ctx.fillStyle = '#a855f7';
  ctx.fill();

  // Centre: angle display OR gamma watermark
  if (angleText !== undefined && angleText !== null) {
    // Angle readout
    ctx.globalAlpha = 0.9;
    ctx.font = '700 24px -apple-system, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // Shadow for readability
    ctx.shadowColor = 'rgba(168,85,247,0.5)';
    ctx.shadowBlur = 12;
    ctx.fillStyle = '#a855f7';
    ctx.fillText(angleText, cx, cy - R * 0.45);
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.fillText(angleText, cx, cy - R * 0.45);
    ctx.globalAlpha = 1;
  } else {
    // Gamma watermark (default)
    ctx.globalAlpha = 0.7;
    ctx.font = '300 36px Georgia, serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(168,85,247,0.65)';
    ctx.shadowBlur = 18;
    ctx.fillStyle = 'rgba(168,85,247,0.4)';
    ctx.fillText('\u03B3', cx, cy - R * 0.50);
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'rgba(255,255,255,0.45)';
    ctx.fillText('\u03B3', cx, cy - R * 0.50);
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

function drawPreview() {
  var canvas = document.getElementById('protoCanvas');
  var scale = 2;
  var pad = 16;
  var fullW = (PREVIEW_R + pad) * 2;
  var fullH = PREVIEW_R + pad + 28;
  canvas.width = Math.round(fullW * scale);
  canvas.height = Math.round(fullH * scale);
  canvas.style.width = fullW + 'px';
  canvas.style.height = fullH + 'px';
  var ctx = canvas.getContext('2d');
  drawProtractorOnCtx(ctx, PREVIEW_R, pad, scale, null);
}

function renderFullProtractor(angleDeg) {
  var R = 160;
  var pad = 24;
  var scale = 3;
  var fullW = (R + pad) * 2;
  var fullH = R + pad + 36;
  var offCanvas = document.createElement('canvas');
  offCanvas.width = Math.round(fullW * scale);
  offCanvas.height = Math.round(fullH * scale);
  var ctx = offCanvas.getContext('2d');
  var angleStr = (angleDeg !== undefined && angleDeg !== null) ? angleDeg.toFixed(1) + '\u00B0' : null;
  drawProtractorOnCtx(ctx, R, pad, scale, angleStr);
  return offCanvas.toDataURL('image/png');
}

drawPreview();

/* ── Place on Board ────────────────────────────────── */
var placeBtn = document.getElementById('placeBtn');

placeBtn.addEventListener('click', async function () {
  placeBtn.disabled = true;
  placeBtn.textContent = 'Placing\u2026';

  try {
    var png = renderFullProtractor(0);
    var viewport = await miro.board.viewport.get();
    var centerX = viewport.x + viewport.width / 2;
    var centerY = viewport.y + viewport.height / 2;

    var img = await miro.board.createImage({
      url: png,
      title: 'PP Protractor',
      x: centerX,
      y: centerY,
      width: 400
    });

    await img.setMetadata('pp-protractor', { type: 'protractor' });
    await miro.board.viewport.zoomTo(img);
    await miro.board.notifications.showNotification('Protractor placed on board');
  } catch (err) {
    console.error('Failed to place protractor:', err);
    await miro.board.notifications.showNotification('Failed to place protractor');
  }

  placeBtn.disabled = false;
  placeBtn.textContent = 'Place on Board';
});

/* ── Selection & Rotation Controls ─────────────────── */
const selectedSection = document.getElementById('selectedSection');
const angleDisplay = document.getElementById('angleDisplay');
const angleInput = document.getElementById('angleInput');
const setAngleBtn = document.getElementById('setAngleBtn');
const readAngleBtn = document.getElementById('readAngleBtn');

let pollInterval = null;
let lastKnownAngle = null;
let renderDebounce = null;
let isReRendering = false;
let selectedItemId = null;

function updateAngleUI(angle) {
  angleDisplay.textContent = angle.toFixed(1) + '\u00B0';
  angleInput.value = angle.toFixed(1);
}

function startPolling(item) {
  stopPolling();
  selectedItem = item;
  selectedItemId = item.id;
  lastKnownAngle = item.rotation || 0;
  updateAngleUI(lastKnownAngle);
  selectedSection.classList.add('visible');

  pollInterval = setInterval(async () => {
    if (isReRendering) return;
    try {
      const items = await miro.board.getSelection();
      const current = items.find(i => i.id === selectedItemId);
      if (!current) { stopPolling(); hideSelected(); return; }

      const angle = current.rotation || 0;
      if (Math.abs(angle - lastKnownAngle) > 0.05) {
        lastKnownAngle = angle;
        selectedItem = current;
        updateAngleUI(angle);

        // Debounce: re-render image 1s after rotation stops
        clearTimeout(renderDebounce);
        renderDebounce = setTimeout(() => {
          reRenderImage(angle);
        }, 1000);
      }
    } catch (e) {}
  }, 300);
}

function stopPolling() {
  if (pollInterval) { clearInterval(pollInterval); pollInterval = null; }
  if (renderDebounce) { clearTimeout(renderDebounce); renderDebounce = null; }
}

function hideSelected() {
  stopPolling();
  selectedItem = null;
  selectedItemId = null;
  selectedSection.classList.remove('visible');
}

async function reRenderImage(angle) {
  if (!selectedItem || isReRendering) return;
  isReRendering = true;

  try {
    const png = renderFullProtractor(angle);
    const x = selectedItem.x;
    const y = selectedItem.y;
    const w = selectedItem.width;

    await miro.board.remove(selectedItem);

    const newImg = await miro.board.createImage({
      url: png,
      title: 'PP Protractor',
      x: x,
      y: y,
      width: w,
      rotation: angle
    });

    await newImg.setMetadata('pp-protractor', { type: 'protractor' });

    selectedItem = newImg;
    selectedItemId = newImg.id;
    updateAngleUI(angle);
  } catch (err) {
    console.error('Re-render error:', err);
  } finally {
    isReRendering = false;
  }
}

// Read current angle from board
readAngleBtn.addEventListener('click', async () => {
  if (!selectedItem) return;
  try {
    const items = await miro.board.getSelection();
    const item = items.find(i => i.id === selectedItemId);
    if (item) {
      lastKnownAngle = item.rotation || 0;
      selectedItem = item;
      updateAngleUI(lastKnownAngle);
    }
  } catch (e) {
    console.error('Read angle error:', e);
  }
});

// Set angle manually
setAngleBtn.addEventListener('click', async () => {
  if (!selectedItem) return;
  const newAngle = parseFloat(angleInput.value) || 0;
  stopPolling();
  setAngleBtn.textContent = '...';
  await reRenderImage(newAngle);
  setAngleBtn.textContent = 'Set';
  if (selectedItem) startPolling(selectedItem);
});

// Preset buttons
document.querySelectorAll('.preset-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    angleInput.value = btn.getAttribute('data-angle');
    setAngleBtn.click();
  });
});

// Listen for selection changes
miro.board.ui.on('selection:update', async (event) => {
  if (isReRendering) return;
  const items = event.items;
  if (items.length === 1) {
    try {
      const meta = await items[0].getMetadata('pp-protractor');
      if (meta && meta.type) {
        startPolling(items[0]);
        return;
      }
    } catch (e) {}
  }
  hideSelected();
});
</script>

</body>
</html>
